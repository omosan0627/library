詰まったらこれ見てみるor方針(というか初手)変える。

考察Face
グラフプロットテーブル(見やすく)
↓
いろいろいじってみる(単純な問題、Nがデカイとき小さい時)
↓
お気持ちを探る(独立単調性順番最大値注目(多項式の入り口))
↓
証明
↓
実装Face
dp貪欲フロー(多項式)
↓
高速化(累積和分割統治)(オーダー小さく)

連続(累積和など)、単調(ならし計算)、凸(貪欲法)が重要。
オーダーを落とす際の基本は「まとめる」
区別をしない　AGC014E
時系列で物を使うとき、使っているものを使っていないことにしたりする AOJ2266 ARC072F
あるものを違うものにうまく変換して見通しをよくする(見比べない) AGC017C
特殊ケースでの言い換えをいろんなケースに適応してみる AGC017C
保持するものを変える AGC014E ARC074E
最大最小に注目する ARC074E
独立を考える
独立性は数式から ARC075F
文字列比較は文字数から ARC080E
実装と考察を混同しない 
詰まったら実装的な考察をしてみる。数式で厳密に書き出してみる。
区間は累積和(orそれと似ているの)。部分に言い換える ARC080F POJ2566
考察は部分を大切にする。自明を大切にする
すべての問題は(dp or 貪欲 or フロー)
dpは愚直+高速化,貪欲は頭良く ARC086
単調性を利用する。特にstack,queue,setスライドや、dp分割統治法高速化
dpの状態の減らし方は1つの変数まるまるいらないor部分的にいらない AGC017F
シンプルな言い換えが重要
考察は分割、実装も分割
性質を見出して、問題を言い換える
何かの値を決めてみる。固定する
値を決める順番を考える
順番を変えてDPできるようにする CodeFestival2016GrandFinalF 
順番を単純化して実装を軽くする AGC019E
細部にすぐ入り込まない
完成形から考える。逆から考える。
声に出して考える感じ
つまったら別のグラフを書いてみる ARC082D
つまったら方針すぐ変える
明確な考察ができるまではアルゴリズムに走らない
回転は列。無駄に二倍の列を作らない。 AGC019D
自分で適当なサンプルを作る際はN=10くらいがよさそう。
文字列は周期。 ARC077F
単純な記号の組み合わせで考察する。 AGC019E Tenka2013FinalD
文字をおいて考察する。
ゆるーく考えたり(緩和)キツく考える(固定) Tenka2016EliminationA:D AOJ 2427
わからない問題はフローor数学 POJ2345
O(NlogN)は貪欲orDP高速化=愚直に値を持つDP CF441E
DPは全探索+状態で求めたいものをきれいに分割+遷移の単純化 CodeFestival2017C:F
DPはまず小さい問題から大きな問題が解けないか考えてみる ARC085F
DPの高速化は1.貪欲的に考えて遷移や状態をO(1)に。2.累積和orSegtree。3.分割統治法 
1.CF883D 2.CodeFestival2017C:F,ARC085F 3.CF868F
数え上げは求めたいものが全探索のただひとつのノードと対応しているか見る CodeFestival2017C:F
無駄に再帰しない ARC084E
条件は1つの要素に対して考える CodeFestival2017C:F CF889C
遷移が複雑なのは一旦DPから離れる Codefestival2017C:F
まずは性質から、次に数式
息の長い議論は議論の切れ目に着目する ARC089F
必要条件は十分条件、上界は最大値 CodeFestival2016GrandFinalE DISCO2016本戦D
上から見積もったり、下から見積もったり、部分的に見積もったりする。 AGC018D
数式がダメならDPを考える DISCO2016本戦D
重要でない情報は捨てる
困ったら簡単な問題にしていろいろ試してみる。頭を動かす。
適用の準備を変えてみる。考察のステップの踏み方を入れ替える。
確定できる情報(YES/NO,順序etc.)を大切にする。それらを確定してみる。
お気持ちから必要十分な条件を導く。
極限状態(大きいケースとか)からお気持ちを探る。 AGC020D
無向グラフで考えていたものに向きをつけて有向グラフにする GCJ2017RoundC:C AGC010E
なにか順序をつけて取っていく操作をDFSからのトポロジカル順とみる AGC010E AGC002F
FFT,行列累乗とかへんな高速化を行う問題は数式を使うが、ほかは絵を描いたほうが思いつきやすい。AGC017F
数式は相当綺麗じゃない限り使わない。
難問は見方を変えながらいろいろなケースの図を書く。
図を過信しすぎてもいけない。
言い換える余地がなさそうな問題はひたすら図を描いて何をやっているか把握orDP
まとめようと思ったら大きいケースを考える。ちまちま考えない。 ARC092D
情報をそぎ落としていくDPはボトムアップ、必要条件を考えるconstructive、感覚で攻める貪欲はトップダウン ARC092F
雑に考える。全体の構造を先に見に行く。
DPは状態を考えてから考察する。考察を先にしないこと。
いい条件に言い換える。いい条件とは必要最低限の情報で必要かつ十分であるもの。特にDP
数え上げDPはダブリ含んでいいからとりあえず形にして、それから重みをつけてダブリを取り除く AGC013D
DPで詰まったら順番変えて見てみるor情報十分系か見てみる。
言い換えに時間を割きすぎない。それよりも順番とか気にする。



木のpathは重心を使って見通し良く ARC087F
木の次数に注目 ARC088F
区間は小さく分ける ARC068E
ゲームはgrundy or dp ARC087E
ゲームは偶奇 AGC010D
無向グラフはdfs木orUnionFind(マージテクを含む) CF434D
dfs木は下から見る。上からはあまり情報得られない。 CF434D
グラフ構築問題はウニグラフなど特徴的なものを疑う。 CF AIM Tech Round4C
構築問題にも秩序あり。定式化できそうな良い構造を見つける AGC012C
構築問題は必要条件=十分条件、小さい差を大きなもので無視する、a^nオーダー
木は点と辺(とgrundy)のどれを主役にするかが大事 TDPC_P AGC017D
dpの意味をきちんと見出す ARC081E
高難易度の問題でWAを出したときこそ細かいミスをしていないか見る AOJ2230
最大値を求めるならlv=m最小値ならrv=m、初期値でミスらない AOJ2230
値の遷移を有向グラフで表せそうなら表してみる AGC016D AGC019E
マンハッタン距離は45度回転 CodeFestival2017A:D
包除原理は集合の重なり具合が本質 Tenka2013FinalD
包除原理は具体的な形を書き出してからまとめる CodeFestival2017EX
包除原理は(全体-満たさないやつ)のイメージ CodeFestival2017EX
包除原理を使いたいなら式を書く。故に定義が大事。 AGC016F
包除原理でandはbitが増えるごとに範囲が狭まり、orは広くなる
包除原理は求めるものをandで書いてもorで書いても問題ない CodeFestival2017EX
構成ゲーはお気持ちを大切にする。 Tenka2016EliminationA:D
構成ゲーは2^n、まとまり、順番に意識する Tenka2016EliminationA:D, CodeFestival2017A:D, CF AIM Tech Round4C
複雑なコンビネーションの式は経路の問題に落としこむ CodeFestival2017A:E
modの問題は式が重要。 POJ1150
ゲームは負けの状態or同じ問題n個でGrundy SRM637Medium
行列累乗で詰まったら1つ要素を増やすことを考える Leonardo's Numbers
煩雑な数え上げは余事象+単純な場合の数
一次式はConvex Hull Trick coloconfinalC
たくさんの二分探索は並列二分探索 AGC002D
部分列の比較はsuffix array CodeFestival2016ETR1:B
O(右の木*左の木)でmergeできるなら二乗の木dp CodeFestival2017EX:A
segtreeに木とか列とか乗せるとO(logN)*(操作のorder)でできる
平方分割は実装が楽だがsegtreeより遅い。
とりあえず無向グラフを書いてみる Codefestival2016grandfinalE CodeFestivalFinal2017E
コンビネーション(の和)はパスカルの三角形or経路数で考える ARC061F
選ぶ問題はどちらかの値を0にすると見通しがつきやすい AGC018C
平均を取る、mergeするのような操作は木で見てみる AGC009E
漸化式のΣは最後の項を分離してみる、添字を1つ減らす AGC013E 蟻本p59

構成ゲー、DP苦手。
